#include <stdio.h>
#include "src/lib/terminal.h"
#include "src/lib/error_handling.h"
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

#define SK_INVALID_ARGS -1
#define SK_MOVE_SUCCESS -2

#define ENEMIES 3
#define ENEMY_SIZE 5

typedef struct {
    int x, y, width, height;
} UIRect;

typedef struct _SKMinion SKMinion;

struct _SKMinion {
    UIRect dim;
    bool is_drawn;
    char border;
    SKMinion *container;
};

#define MAX_MINIONS 5

typedef struct {
    SKMinion *minions[MAX_MINIONS];
    int num_minions;
} SKGru;

void _draw_rect(UIRect dim, char c)
{
    printf("\033[%d;%dH", dim.y, dim.x);
    for (int i = 0; i < 2 * dim.width; i++)
        fputc(c, stdout);

    for (int j = dim.y + 1; j < dim.y + dim.height - 1; j++) {
        printf("\033[%d;%dH", j, dim.x);
        putc(c, stdout);
        printf("\033[%d;%dH", j, dim.x + 2 * dim.width - 1);
        fputc(c, stdout);
    }

    printf("\033[%d;%dH", dim.y + dim.height - 1, dim.x);
    for (int i = 0; i < 2 * dim.width; i++)
        fputc(c, stdout);
    fflush(stdout);
}

SKMinion *sk_minion_new(UIRect dim, char border, SKMinion *container)
{
    SKMinion *m = oopsalloc(1, sizeof(SKMinion), "sk_minion_new");

    m->dim = dim;
    m->border = border;
    m->container = container;
    return m;
}

void sk_minion_destroy(SKMinion *m)
{
    if (!m)
        return;

    free(m);
}

void sk_minion_draw(SKMinion *m) {
    if (!m || m->dim.x < 1 || m->dim.y < 1)
        return;

    _draw_rect(m->dim, m->border);
    m->is_drawn = true;
}

bool sk_minion_is_position_inside(SKMinion *c, int x, int y)
{
    if (!c)
        return false;

    return x > c->dim.x && x < c->dim.x + 2 * c->dim.width - 1
        && y > c->dim.y && y < c->dim.y + c->dim.height;
}

bool sk_minion_is_position_overlapping(SKMinion *c, int x, int y)
{
    if (!c)
        return false;

    return x >= c->dim.x && x < c->dim.x + 2 * c->dim.width
        && y >= c->dim.y && y <= c->dim.y + c->dim.height - 1;
}

void sk_minion_move(SKMinion *m, int x, int y) {
    if (!m || x < 1 || y < 1) {
        HE("invalid arguments", "sk_minion_move");
        return;
    }

    // if we're inside something, check that we don't go outside
    if (m->container && (!sk_minion_is_position_inside(m->container, x, y) ||
                !sk_minion_is_position_inside(m->container, x + m->dim.width, y + m->dim.height)))
        return;

    // if already drawn, erase it
    if (m->is_drawn)
        _draw_rect(m->dim, ' ');

    // move it
    m->dim.x = x, m->dim.y = y;

    // for now, draw the dim
    sk_minion_draw(m);
}

SKGru *sk_gru_new()
{
    return oopsalloc(1, sizeof(SKGru), "sk_gru_new");
}

void sk_gru_add_minion(SKGru *g, SKMinion *m) {
    if (!g || !m)
        return;

    if (g->num_minions >= MAX_MINIONS)
        return;

    g->minions[g->num_minions++] = m;
}

void sk_gru_draw(SKGru *g) {
    if (!g)
        return;

    for (int i = 0; i < g->num_minions; i++)
        sk_minion_draw(g->minions[i]);
}

void sk_gru_move(SKGru *g, SKMinion *m, int x, int y)
{
    if (!g || !m) {
        HE("invalid arguments (they're NULL)", "sk_gru_move");
        return;
    }

    sk_minion_move(m, x, y);
}

/**
 * Attempts to move the given SKMinion without overlapping other SKMinions
 * inside the given SKGru.
 *
 * Returns SK_MOVE_SUCCESS if the move was correct, otherwise, returns the
 * index of the SKMinion we collided with inside the SKGru.
 *
 * Returns SK_INVALID_ARGS if the provided arguments are not valid.
 */
int sk_gru_non_overlapping_move(SKGru *g, SKMinion *m, int x, int y)
{
    if (!g || !m || x < 1 || y < 1)
        return SK_INVALID_ARGS;

    for (int i = 0; i < g->num_minions; i++) {
        if (g->minions[i] != m && sk_minion_is_position_overlapping(g->minions[i], x, y))
            return i;
    }

    sk_gru_move(g, m, x, y);
    return SK_MOVE_SUCCESS;
}

void sk_gru_destroy(SKGru *g)
{
    if (!g)
        return;

    for (int i = 0; i < g->num_minions; i++)
        sk_minion_destroy(g->minions[i]);

    free(g);
}

SKGru *g;
int game_ended;

void *move_enemies(void *sth)
{
    SKGru *g = (SKGru *)sth;

    // array of speeds initialized to 1
    int t[ENEMIES];
    for (int i = 0; i < ENEMIES; t[i++] = 1);

    while (1) {
        usleep(1e5);
        for (int i = 0; i < ENEMIES; i++) {
            if (g->minions[i]->dim.x + g->minions[i]->dim.width >= 80)
                t[i] = -1;
            else if (g->minions[i]->dim.x <= 1)
                t[i] = 1;

            if (SK_MOVE_SUCCESS != (game_ended = sk_gru_non_overlapping_move(g, g->minions[i], g->minions[i]->dim.x + t[i], g->minions[i]->dim.y)))
            {

                return NULL;
            }
        }
    }
    return NULL;
}


int main(void)
{
    // setup terminal and clear the screen
    term_setup(stdin, stdout);
    printf("\033[2J");

    g = sk_gru_new();

    // create enemies
    SKMinion *enemies[ENEMIES];
    for (int i = 0; i < ENEMIES; i++) {
        enemies[i] = sk_minion_new((UIRect) { 1 + i * 2 * ENEMY_SIZE, 1 + i *ENEMY_SIZE, ENEMY_SIZE, ENEMY_SIZE }, '+', NULL);
        sk_gru_add_minion(g, enemies[i]);
    }

    // create player
    SKMinion *player;
    player = sk_minion_new((UIRect) { 2 * ENEMY_SIZE + 1, 5, 1, 1 }, '@', NULL);
    sk_gru_add_minion(g, player);

    sk_gru_draw(g);

    pthread_t thr;
    pthread_create(&thr, NULL, move_enemies, (void *)g);

    // listen for keyboard input
    int key;
    while ((key = term_read_key(stdin)) != 'q')
    {
        if (term_is_arrow_key(key)) {
            int res;
            switch (key) {
                case UP_ARROW:
                    res = sk_gru_non_overlapping_move(g, player, player->dim.x, player->dim.y - 1);
                    break;
                case DOWN_ARROW:
                    res = sk_gru_non_overlapping_move(g, player, player->dim.x, player->dim.y + 1);
                    break;
                case LEFT_ARROW:
                    res = sk_gru_non_overlapping_move(g, player, player->dim.x - 1, player->dim.y);
                    break;
                case RIGHT_ARROW:
                    res = sk_gru_non_overlapping_move(g, player, player->dim.x + 1, player->dim.y);
                    break;
            }

            if (res >= 0) {
                printf("You collided with UIMinion %d. Game over!\n", res);
                break;
            }
        }
    }

    sk_gru_destroy(g);
    term_teardown(stdin, stdout);
    return 0;
}
